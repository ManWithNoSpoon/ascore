// Generated by CoffeeScript 1.8.0
(function() {
  var AError, InvalidArrError, InvalidCombineFunError, InvalidDoneCbError, InvalidFCollectItem, InvalidFilterCbError, InvalidItemCbError, InvalidMapCbError, InvalidPushItemError, InvalidReduceCbError, InvalidValsError, LIMIT_MAX_RUNNING_DEFAULT, bindSeq, bindSeqFun, bindSeqer, chainTriggersTo, collect, collectItem, collector, decSeqer, each, eachPair, eacher, fcollect, fcollectItem, fcollector, filter, filterer, flob, flobber, limit, lob, lobber, makeEacherFun, makeFiltererFun, makeLobFun, makeMapperFun, map, mapPairs, mapper, push, reduce, reducer, sequence, sequencer, sloppyEach, sloppyEacher, sloppyFilter, sloppyFilterer, sloppyMap, sloppyMapper, wrap0Arg, wrap1Arg, wrap2Arg, wrap3Arg, wrap4Arg, wrapFun, wrapFunWithCatch, _each, _filter, _map, _push, _reduce, _sequence,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  LIMIT_MAX_RUNNING_DEFAULT = 16;

  
if (require) var _ = require('underscore');

//if (typeof(window) != 'undefined' && typeof(exports) == 'undefined')
//	var exports = window.A_ = {};
;


  /*
  Most functions passed to Ascore's API have to be asynchronous. (Not really, but
  they should expect a callback.) Use the functions below to wrap your synchronous
  functions:
   */

  wrap0Arg = function(f, ctx) {
    return function(cb) {
      return cb(null, f.call(ctx || this));
    };
  };

  wrap1Arg = function(f, ctx) {
    return function(a, cb) {
      return cb(null, f.call(ctx || this, a));
    };
  };

  wrap2Arg = function(f, ctx) {
    return function(a, b, cb) {
      return cb(null, f.call(ctx || this, a, b));
    };
  };

  wrap3Arg = function(f, ctx) {
    return function(a, b, c, cb) {
      return cb(null, f.call(ctx || this, a, b, c));
    };
  };

  wrap4Arg = function(f, ctx) {
    return function(a, b, c, d, cb) {
      return cb(null, f.call(ctx || this, a, b, c, d));
    };
  };

  exports.wrap0Arg = exports.w0A = wrap0Arg;

  exports.wrap1Arg = exports.w1A = wrap1Arg;

  exports.wrap2Arg = exports.w2A = wrap2Arg;

  exports.wrap3Arg = exports.w3A = wrap3Arg;

  exports.wrap4Arg = exports.w4A = wrap4Arg;

  exports.wrapFun = wrapFun = function(fun, ctx) {
    if (ctx == null) {
      ctx = null;
    }
    return function() {
      var args, cb, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      return cb(null, fun.apply(ctx || this, args));
    };
  };

  exports.wrapFunWithCatch = wrapFunWithCatch = function(fun, ctx) {
    if (ctx == null) {
      ctx = null;
    }
    return function() {
      var args, caught, cb, err, val, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
      try {
        val = fun.apply(ctx || this, args);
      } catch (_error) {
        err = _error;
        caught = true;
        cb(err, null);
      }
      if (!caught) {
        return cb(null, val);
      }
    };
  };

  exports.each = each = function(arr, doItem, doneCb) {
    if (!_.isFunction(doneCb)) {
      throw new InvalidDoneCbError("Done callback not a valid function: " + doneCb);
    } else if (!_.isFunction(doItem)) {
      return doneCb(new InvalidItemCbError("Item callback not a valid function: " + doItem));
    } else if (!_.isArray(arr) && !_.isObject(arr)) {
      return doneCb(new InvalidArrError("Not a valid array or hash: " + arr));
    } else if (_.isFunction(arr)) {
      return arr(function(err, arr) {
        if (err) {
          return doneCb(err);
        } else if (!_.isArray(arr) && !_.isObject(arr)) {
          return doneCb(new InvalidArrError("Not a valid array or hash: " + arr));
        } else {
          return _each(arr, doItem, doneCb);
        }
      });
    } else {
      return _each(arr, doItem, doneCb);
    }
  };

  exports.sloppyEach = sloppyEach = function(arr, doItem, doneCb) {
    if (_.isFunction(arr)) {
      return arr(function(err, arr) {
        if (err) {
          return doneCb(err);
        } else {
          return _each(arr, doItem, doneCb);
        }
      });
    } else {
      return _each(arr, doItem, doneCb);
    }
  };

  _each = function(arr, doItem, doneCb) {
    var errord, waiting;
    if (_.isArray(arr)) {
      waiting = arr.length;
    } else {
      waiting = _.keys(arr).length;
    }
    if (!waiting) {
      return doneCb(null);
    } else {
      errord = false;
      return _.each(arr, function(item, i) {
        if (errord) {
          return;
        }
        return doItem(item, i, function(err) {
          if (err) {
            errord = true;
            return doneCb(err);
          } else if (!--waiting) {
            return doneCb(null);
          }
        });
      });
    }
  };

  makeEacherFun = function(each) {
    return function(arr, doItem) {
      var _ref;
      if (doItem == null) {
        doItem = null;
      }
      _ref = [null, arr], arr = _ref[0], doItem = _ref[1];
      if (!_.isFunction(doItem)) {
        throw new InvalidItemCbError("Item callback not a valid function: " + doItem);
      }
      if (arr) {
        return function(doneCb) {
          return each(arr, doItem, doneCb);
        };
      } else {
        return function(arr, doneCb) {
          return each(arr, doItem, doneCb);
        };
      }
    };
  };

  exports.eacher = eacher = makeEacherFun(each);

  exports.sloppyEacher = sloppyEacher = makeEacherFun(sloppyEach);

  exports.map = map = function(arr, vals, doItem, mapCb) {
    var _ref;
    if (mapCb == null) {
      mapCb = null;
    }
    if (mapCb === null) {
      _ref = [null, vals, doItem], vals = _ref[0], doItem = _ref[1], mapCb = _ref[2];
    }
    if (!_.isFunction(mapCb)) {
      throw new InvalidMapCbError("Callback for mapped values not a valid function: " + mapCb);
    } else if (!_.isFunction(doItem)) {
      return mapCb(new InvalidItemCbError("Item callback not a valid function: " + doItem), null);
    } else if (!_.isArray(arr) && !_.isObject(arr)) {
      return mapCb(new InvalidArrError("Not a valid array or hash: " + arr), null);
    } else if (_.isFunction(arr)) {
      return arr(function(err, arr) {
        if (err) {
          return mapCb(err, null);
        } else if (!_.isArray(arr) && !_.isObject(arr)) {
          return mapCb(new InvalidArrError("Not a valid array or hash: " + arr), null);
        } else if (vals && _.isArray(arr)) {
          return mapCb(new InvalidValsError("No existing values may be provided when mapping an array"), null);
        } else {
          return _map(arr, vals, doItem, mapCb);
        }
      });
    } else if (vals && _.isArray(arr)) {
      return mapCb(new InvalidValsError("No existing values may be provided when mapping an array"), null);
    } else {
      return _map(arr, vals, doItem, mapCb);
    }
  };

  exports.sloppyMap = sloppyMap = function(arr, vals, doItem, mapCb) {
    var _ref;
    if (mapCb == null) {
      mapCb = null;
    }
    if (mapCb === null) {
      _ref = [null, vals, doItem], vals = _ref[0], doItem = _ref[1], mapCb = _ref[2];
    }
    if (_.isFunction(arr)) {
      return arr(function(err, arr) {
        if (err) {
          return mapCb(err, null);
        } else {
          return _map(arr, vals, doItem, mapCb);
        }
      });
    } else {
      return _map(arr, vals, doItem, mapCb);
    }
  };

  _map = function(arr, vals, doItem, mapCb) {
    vals = _.isArray(arr) ? [] : vals || {};
    _each(arr, function(item, i, doneCb) {
      return doItem(item, function(err, val) {
        if (err) {
          return doneCb(err);
        } else {
          vals[i] = val;
          return doneCb(null);
        }
      });
    }, function(err) {
      if (err) {
        return mapCb(err, null);
      } else {
        return mapCb(null, vals);
      }
    });
    return vals;
  };

  makeMapperFun = function(map) {
    return function(arr, vals, doItem) {
      var _ref, _ref1;
      if (vals == null) {
        vals = null;
      }
      if (doItem == null) {
        doItem = null;
      }
      if (doItem === null) {
        if (vals === null) {
          _ref = [null, null, arr], arr = _ref[0], vals = _ref[1], doItem = _ref[2];
        } else {
          _ref1 = [arr, null, vals], arr = _ref1[0], vals = _ref1[1], doItem = _ref1[2];
        }
      }
      if (!_.isFunction(doItem)) {
        throw new InvalidItemCbError("Item callback not a valid function: " + doItem);
      }
      if (vals) {
        if (arr) {
          return function(mapCb) {
            return map(arr, vals, doItem, mapCb);
          };
        } else {
          return function(arr, mapCb) {
            return map(arr, vals, doItem, mapCb);
          };
        }
      } else {
        if (arr) {
          return function(vals, mapCb) {
            var _ref2;
            if (mapCb == null) {
              mapCb = null;
            }
            if (mapCb === null) {
              _ref2 = [null, vals], vals = _ref2[0], mapCb = _ref2[1];
            }
            return map(arr, vals, doItem, mapCb);
          };
        } else {
          return function(arr, vals, mapCb) {
            var _ref2;
            if (mapCb == null) {
              mapCb = null;
            }
            if (mapCb === null) {
              _ref2 = [null, vals], vals = _ref2[0], mapCb = _ref2[1];
            }
            return map(arr, vals, doItem, mapCb);
          };
        }
      }
    };
  };

  exports.mapper = mapper = makeMapperFun(map);

  exports.sloppyMapper = sloppyMapper = makeMapperFun(sloppyMap);


  /*
  Like each or map, but results are passed to pushItem, in order, when they become
  available. (Any errors are passed to doneCb.)
   */

  exports.push = push = function(arr, doItem, pushItem, doneCb) {
    if (!_.isFunction(doneCb)) {
      throw new InvalidDoneCbError("Done callback not a valid function: " + doneCb);
    } else if (!_.isFunction(pushItem)) {
      doneCb(new InvalidPushItemError("Push-item-function not a valid function"));
    } else if (!_.isFunction(doItem)) {
      doneCb(new InvalidItemCbError("Item callback not a valid function: " + doItem));
    } else if (!_.isArray(arr)) {
      doneCb(new InvalidArrError("Not a valid array: " + arr));
    }
    return _push(arr, doItem, pushItem, doneCb);
  };

  exports.sloppyPush = _push = function(arr, doItem, pushItem, doneCb) {
    var offset, vals, waiting;
    offset = 0;
    vals = [];
    waiting = arr.length;
    if (!waiting) {
      doneCb(null);
    }
    return _.each(arr, function(item, i) {
      return doItem(item, function(err, val) {
        var _results;
        if (err) {
          doneCb(err);
          return;
        }
        if (val === void 0) {
          throw new InvalidItemCbError("Push item iterator should never give back undefined, use null instead");
        }
        vals[i - offset] = val;
        _results = [];
        while (vals[0] !== void 0) {
          ++offset;
          _results.push(pushItem(vals.shift(), function(err) {
            if (err) {
              return doneCb(err);
            } else if (!--waiting) {
              return doneCb(null);
            }
          }));
        }
        return _results;
      });
    });
  };


  /*
  exports.sloppySlide =
  _slide = (arr, pushItemFuns..., doneCb) ->
  	vals    = [ arr ]
  	offsets = [ 0 ]
  	
  	waiting = arr.length
  	
  	while vals.length < pushItemFuns.length
  		vals.push     []
  		offsets.push  0
  		
  		waiting += arr.length
  	
  	_.each pushItemFuns, (pushItem, i) ->
  		_.each vals[i], (item, j) ->
  			pushItem item, (err, val) ->
  				if err
  					doneCb err, null
  				
  				vals[i][j] 
  				
  				if not --waiting
  					doneCb null
   */

  exports.eachPair = eachPair = function(arr, doPair, eachPairCb) {
    var errord, i, vals, waiting, _results;
    errord = false;
    waiting = Math.ceil(arr.length / 2);
    if (!waiting) {
      eachPairCb(null, []);
      return;
    }
    vals = [];
    i = 0;
    _results = [];
    while (i < arr.length) {
      (function(i) {
        var a, b;
        if (errord) {
          return;
        }
        a = arr[i];
        b = i + 1 < arr.length ? arr[i + 1] : void 0;
        return doPair(a, b, i, function(err) {
          if (err) {
            errord = true;
            return eachPairCb(err);
          } else {
            if (!--waiting) {
              return eachPairCb(null);
            }
          }
        });
      })(i);
      _results.push(i += 2);
    }
    return _results;
  };

  exports.mapPairs = mapPairs = function(arr, doPair, mapPairsCb) {
    var vals;
    vals = [];
    return eachPair(arr, function(a, b, i, cb) {
      return doPair(a, b, function(err, val) {
        vals[i / 2] = val;
        return cb(null);
      });
    }, function(err) {
      if (err) {
        return mapPairsCb(err, null);
      } else {
        return mapPairsCb(null, vals);
      }
    });
  };


  /*
  DISCLAIMER: Unless the existence of this function is justified (over using an
  async map and a regular reduce), it is expected to be removed in a later
  release. Use at your own risk!
   */

  exports.reduce = reduce = function(arr, defaultVal, combine, reduceCb) {
    var _ref;
    if (reduceCb == null) {
      reduceCb = null;
    }
    if (reduceCb === null) {
      _ref = [void 0, defaultVal, combine], defaultVal = _ref[0], combine = _ref[1], reduceCb = _ref[2];
    }
    if (!_.isFunction(reduceCb)) {
      throw new InvalidReduceCbError("Callback for reduced value not a valid function: " + reduceCb);
    } else if (!_.isFunction(combine)) {
      return reduceCb(new InvalidCombineFunError("Combine function not a valid function: " + combine), null);
    } else if (!_.isArray(arr)) {
      return reduceCb(new InvalidArrError("Not a valid array: " + arr), null);
    } else {
      return _reduce(arr, defaultVal, combine, reduceCb);
    }
  };

  _reduce = function(arr, defaultVal, combine, reduceCb, run) {
    var vals;
    if (run == null) {
      run = 0;
    }
    if (arr.length === 0) {
      reduceCb(null, defaultVal);
      return;
    }
    vals = [];
    return eachPair(arr, function(a, b, i, cb) {
      if (b === void 0) {
        if (defaultVal === void 0) {
          vals[i / 2] = a;
          cb(null);
          return;
        } else {
          b = defaultVal;
        }
      }
      return combine(a, b, run, function(err, val) {
        if (err) {
          return cb(err);
        } else {
          vals[i / 2] = val;
          return cb(null);
        }
      });
    }, function(err) {
      if (err) {
        return reduceCb(err, null);
      } else {
        if (vals.length === 1) {
          return reduceCb(null, vals[0]);
        } else {
          return _reduce(vals, defaultVal, combine, reduceCb, run + 1);
        }
      }
    });
  };

  exports.reducer = reducer = function(defaultVal, combine) {
    return function(arr, reduceCb) {
      return reduce(arr, defaultVal, combine, reduceCb);
    };
  };

  exports.filter = filter = function(arr, doItem, filterCb) {
    if (!_.isFunction(filterCb)) {
      throw new InvalidFilterCbError("Callback for filtered values not a valid function: " + filterCb);
    } else if (!_.isFunction(doItem)) {
      return filterCb(new InvalidItemCbError("Item callback not a valid function: " + doItem), null);
    } else if (!_.isArray(arr) && !_.isObject(arr)) {
      return filterCb(new InvalidArrError("Not a valid array or hash: " + arr), null);
    } else if (_.isFunction(arr)) {
      return arr(function(err, arr) {
        if (err) {
          return filterCb(err, null);
        } else if (!_.isArray(arr) && !_.isObject(arr)) {
          return filterCb(new InvalidArrError("Not a valid array or hash: " + arr), null);
        } else {
          return _filter(arr, doItem, filterCb);
        }
      });
    } else {
      return _filter(arr, doItem, filterCb);
    }
  };

  exports.sloppyFilter = sloppyFilter = function(arr, doItem, filterCb) {
    if (_.isFunction(arr)) {
      return arr(function(err, arr) {
        if (err) {
          return filterCb(err, null);
        } else {
          return _filter(arr, doItem, filterCb);
        }
      });
    } else {
      return _filter(arr, doItem, filterCb);
    }
  };

  _filter = function(arr, doItem, filterCb) {
    var vals;
    vals = _.isArray(arr) ? [] : {};
    _each(arr, function(item, i, doneCb) {
      return doItem(item, function(err, keep) {
        if (err) {
          return doneCb(err);
        } else {
          if (keep) {
            vals[i] = item;
          }
          return doneCb(null);
        }
      });
    }, function(err) {
      if (err) {
        return filterCb(err, null);
      } else {
        if (_.isArray(arr)) {
          vals = _.filter(vals, function(val) {
            return val !== void 0;
          });
        }
        return filterCb(null, vals);
      }
    });
    return vals;
  };

  makeFiltererFun = function(filter) {
    return function(doItem) {
      if (!_.isFunction(doItem)) {
        throw new InvalidItemCbError("Item callback not a valid function: " + doItem);
      }
      return function(arr, filterCb) {
        return filter(arr, doItem, filterCb);
      };
    };
  };

  exports.filterer = filterer = makeFiltererFun(filter);

  exports.sloppyFilterer = sloppyFilterer = makeFiltererFun(sloppyFilter);

  collectItem = function(item, valCb) {
    if (_.isFunction(item)) {
      return item(valCb);
    } else {
      return valCb(null, item);
    }
  };

  fcollectItem = function(item, valCb) {
    if (!_.isFunction(item)) {
      return valCb(new InvalidFCollectItem("All items passed to fcollect/flob must be functions, got: " + item), null);
    } else {
      return item(valCb);
    }
  };

  exports.collect = collect = mapper(collectItem);

  exports.fcollect = fcollect = mapper(fcollectItem);

  exports.collector = collector = function(vals) {
    if (vals == null) {
      vals = {};
    }
    return mapper(null, vals, collectItem);
  };

  exports.fcollector = fcollector = function(vals) {
    if (vals == null) {
      vals = {};
    }
    return mapper(null, vals, fcollectItem);
  };

  makeLobFun = function(collect) {
    return function(vals, lobCb) {
      return collect(vals, function(err, vals) {
        return lobCb.call(vals, err);
      });
    };
  };

  exports.lob = lob = makeLobFun(collect);

  exports.flob = flob = makeLobFun(fcollect);

  exports.lobber = lobber = function(ctx) {
    if (ctx == null) {
      ctx = {};
    }
    return makeLobFun(collector(ctx));
  };

  exports.flobber = flobber = function(ctx) {
    if (ctx == null) {
      ctx = {};
    }
    return makeLobFun(fcollector(ctx));
  };

  exports.limit = limit = function(maxRunning, fun) {
    var applyFun, argQueue, ctxQueue, running, tryFun, wrapCb, _ref;
    if (fun == null) {
      fun = null;
    }
    if (fun === null) {
      _ref = [LIMIT_MAX_RUNNING_DEFAULT, maxRunning], maxRunning = _ref[0], fun = _ref[1];
    }
    running = 0;
    ctxQueue = [];
    argQueue = [];
    tryFun = function(ctx, args) {
      wrapCb(ctx, args);
      if (running < maxRunning) {
        return applyFun(ctx, args);
      } else {
        ctxQueue.push(ctx);
        return argQueue.push(args);
      }
    };
    wrapCb = function(ctx, args) {
      var cb;
      cb = args.pop();
      return args.push(function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        running--;
        if (argQueue.length) {
          applyFun(ctxQueue.shift(), argQueue.shift());
        }
        return cb.apply(ctx, args);
      });
    };
    applyFun = function(ctx, args) {
      running++;
      return fun.apply(ctx, args);
    };
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return tryFun(this, args);
    };
  };

  exports.sequence = exports.seq = sequence = function() {
    var doneOrErrCb, funs, _i;
    funs = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), doneOrErrCb = arguments[_i++];
    return _sequence(funs, doneOrErrCb, [], {});
  };

  exports.bindSequenceFunction = exports.bindSeqFun = bindSeqFun = function(ctx) {
    return function() {
      var doneOrErrCb, funs, _i;
      funs = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), doneOrErrCb = arguments[_i++];
      return _sequence(funs, doneOrErrCb, [], ctx);
    };
  };

  exports.bindSequence = bindSeq = function() {
    var ctx, doneOrErrCb, funs, _i;
    ctx = arguments[0], funs = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), doneOrErrCb = arguments[_i++];
    return _sequence(funs, doneOrErrCb, [], ctx);
  };

  exports.sequencer = exports.seqer = sequencer = function() {
    var funs;
    funs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function() {
      var args, doneOrErrCb, _funs, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), doneOrErrCb = arguments[_i++];
      _funs = funs.slice(0);
      return _sequence(_funs, doneOrErrCb, args, {});
    };
  };

  exports.bindSequencer = exports.bindSeqer = bindSeqer = function() {
    var ctx, funs;
    ctx = arguments[0], funs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return function() {
      var args, doneOrErrCb, _funs, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), doneOrErrCb = arguments[_i++];
      _funs = funs.slice(0);
      return _sequence(_funs, doneOrErrCb, args, ctx);
    };
  };

  exports.decorateWithSequencer = exports.decSeqer = decSeqer = function() {
    var funs;
    funs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function() {
      var args, doneOrErrCb, _funs, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), doneOrErrCb = arguments[_i++];
      _funs = funs.slice(0);
      return _sequence(_funs, doneOrErrCb, args, this);
    };
  };

  _sequence = function(funs, doneOrErrCb, args, ctx) {
    var fun;
    if (fun = funs.shift()) {
      return fun.apply(ctx, args.concat([
        function() {
          var args, err;
          err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (err) {
            return doneOrErrCb.call(ctx, err);
          } else {
            return _sequence(funs, doneOrErrCb, args, ctx);
          }
        }
      ]));
    } else {
      return doneOrErrCb.apply(ctx, [null].concat(args));
    }
  };

  exports.chainTriggersTo = chainTriggersTo = function(checkForErr, doneCb, doneCbCtx) {
    var waiting, _ref, _ref1;
    if (doneCb == null) {
      doneCb = null;
    }
    if (doneCbCtx == null) {
      doneCbCtx = null;
    }
    if (doneCbCtx === null) {
      if (doneCb === null) {
        _ref = [true, checkForErr], checkForErr = _ref[0], doneCb = _ref[1];
      } else if (_.isFunction(checkForErr)) {
        _ref1 = [true, checkForErr, doneCb], checkForErr = _ref1[0], doneCb = _ref1[1], doneCbCtx = _ref1[2];
      }
    }
    waiting = 0;
    return function(_checkForErr, fun, ctx) {
      var errord, hasFired, _ref2;
      if (_checkForErr == null) {
        _checkForErr = checkForErr;
      }
      if (fun == null) {
        fun = null;
      }
      if (ctx == null) {
        ctx = null;
      }
      if (ctx === null && _.isFunction(_checkForErr)) {
        _ref2 = [checkForErr, _checkForErr, fun], _checkForErr = _ref2[0], fun = _ref2[1], ctx = _ref2[2];
      }
      waiting++;
      hasFired = false;
      if (fun) {
        errord = false;
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return setTimeout(function() {
            var err;
            if (hasFired) {
              return;
            } else {
              hasFired = true;
            }
            if (_checkForErr) {
              if (err = args.pop()) {
                doneCb(err);
              }
            } else {
              args.push(function(err) {
                if (err) {
                  errord = true;
                  return doneCb(err);
                }
              });
            }
            fun.apply(ctx, args);
            if (!errord && !--waiting) {
              return doneCb.call(doneCbCtx, null);
            }
          }, 0);
        };
      } else {
        return function(err) {
          return setTimeout(function() {
            if (hasFired) {
              return;
            } else {
              hasFired = true;
            }
            if (_checkForErr && err) {
              return doneCb.call(doneCbCtx, err);
            } else if (!--waiting) {
              return doneCb.call(doneCbCtx, null);
            }
          }, 0);
        };
      }
    };
  };

  exports.chainBindingsTo = function(checkForErr, doneCb, doneCbCtx) {
    var bindingsFired, currentBindingIndex, doneCbFired, fireDoneCb, lastErrFireCount, _ref, _ref1;
    if (doneCb == null) {
      doneCb = null;
    }
    if (doneCb === null) {
      _ref = [false, checkForErr], checkForErr = _ref[0], doneCb = _ref[1];
    } else if (doneCbCtx === null && _.isFunction(checkForErr)) {
      _ref1 = [false, checkForErr, doneCb], checkForErr = _ref1[0], doneCb = _ref1[1], doneCbCtx = _ref1[2];
    }
    doneCbFired = 0;
    bindingsFired = [];
    currentBindingIndex = 0;
    lastErrFireCount = 0;
    fireDoneCb = function(err) {
      doneCbFired++;
      return doneCb(err);
    };
    return function(_checkForErr, fun, ctx) {
      var bindingIndex;
      if (_checkForErr == null) {
        _checkForErr = checkForErr;
      }
      if (fun == null) {
        fun = null;
      }
      if (ctx == null) {
        ctx = null;
      }
      bindingIndex = currentBindingIndex++;
      bindingsFired[bindingIndex] = 0;
      if (fun) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return setTimeout(function() {
            var err, fired;
            fun.apply(ctx, args);
            fired = ++bindingsFired[bindingIndex];
            if (fired === lastErrFireCount) {
              return;
            }
            if (_checkForErr) {
              if (err = args.pop()) {
                fireDoneCb(err);
                return;
              }
            } else {
              args.push(function(err) {
                if (err) {
                  lastErrFireCount = fired;
                  return fireDoneCb(err);
                }
              });
            }
            if (doneCbFired < Math.min.apply(null, bindingsFired)) {
              return fireDoneCb(null);
            }
          }, 0);
        };
      } else {
        return function(err) {
          return setTimeout(function() {
            var fired;
            fired = ++bindingsFired[bindingIndex];
            if (fired === lastErrFireCount) {
              return;
            }
            if (err) {
              lastErrFireCount = fired;
              return fireDoneCb(err);
            } else if (doneCbFired < Math.min.apply(null, bindingsFired)) {
              return fireDoneCb(null);
            }
          }, 0);
        };
      }
    };
  };

  exports.Error = AError = (function(_super) {
    __extends(AError, _super);

    function AError(message) {
      this.message = message;
      Error.call(this, message);
      Error.captureStackTrace(this, arguments.callee);
    }

    return AError;

  })(Error);

  exports.InvalidDoneCbError = InvalidDoneCbError = (function(_super) {
    __extends(InvalidDoneCbError, _super);

    function InvalidDoneCbError() {
      return InvalidDoneCbError.__super__.constructor.apply(this, arguments);
    }

    return InvalidDoneCbError;

  })(AError);

  exports.InvalidMapCbError = InvalidMapCbError = (function(_super) {
    __extends(InvalidMapCbError, _super);

    function InvalidMapCbError() {
      return InvalidMapCbError.__super__.constructor.apply(this, arguments);
    }

    return InvalidMapCbError;

  })(AError);

  exports.InvalidReduceCbError = InvalidReduceCbError = (function(_super) {
    __extends(InvalidReduceCbError, _super);

    function InvalidReduceCbError() {
      return InvalidReduceCbError.__super__.constructor.apply(this, arguments);
    }

    return InvalidReduceCbError;

  })(AError);

  exports.InvalidItemCbError = InvalidItemCbError = (function(_super) {
    __extends(InvalidItemCbError, _super);

    function InvalidItemCbError() {
      return InvalidItemCbError.__super__.constructor.apply(this, arguments);
    }

    return InvalidItemCbError;

  })(AError);

  exports.InvalidPushItemError = InvalidPushItemError = (function(_super) {
    __extends(InvalidPushItemError, _super);

    function InvalidPushItemError() {
      return InvalidPushItemError.__super__.constructor.apply(this, arguments);
    }

    return InvalidPushItemError;

  })(AError);

  exports.InvalidCombineFunError = InvalidCombineFunError = (function(_super) {
    __extends(InvalidCombineFunError, _super);

    function InvalidCombineFunError() {
      return InvalidCombineFunError.__super__.constructor.apply(this, arguments);
    }

    return InvalidCombineFunError;

  })(AError);

  exports.InvalidArrError = InvalidArrError = (function(_super) {
    __extends(InvalidArrError, _super);

    function InvalidArrError() {
      return InvalidArrError.__super__.constructor.apply(this, arguments);
    }

    return InvalidArrError;

  })(AError);

  exports.InvalidValsError = InvalidValsError = (function(_super) {
    __extends(InvalidValsError, _super);

    function InvalidValsError() {
      return InvalidValsError.__super__.constructor.apply(this, arguments);
    }

    return InvalidValsError;

  })(AError);

  exports.InvalidFilterCbError = InvalidFilterCbError = (function(_super) {
    __extends(InvalidFilterCbError, _super);

    function InvalidFilterCbError() {
      return InvalidFilterCbError.__super__.constructor.apply(this, arguments);
    }

    return InvalidFilterCbError;

  })(AError);

  exports.InvalidFCollectItem = InvalidFCollectItem = (function(_super) {
    __extends(InvalidFCollectItem, _super);

    function InvalidFCollectItem() {
      return InvalidFCollectItem.__super__.constructor.apply(this, arguments);
    }

    return InvalidFCollectItem;

  })(AError);

}).call(this);
